> python与其说是一门语言, 不如说是一个库的集合, python程序员简称: 调包侠




### 必须要会的三个库
1. numpy, 一切的基础, 数据处理
2. matplot, 数据可视化
3. pandas, 对于numpy的再次封装


### 未写代码, 先掉包

```python
# 掉包是最重要的语法, 
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

```


### 基础语法
```python
# 表达式的定义形式, 如果con为真下面的式子为a, 否则就是b, 这货是一个中置运算符
a if con else b
# 链式
a = 1 if n < 10 else 2 if n > 10 else 0
# 实质等于
a = (1 if n < 10 else (2 if n > 10 else 0))

# 循环同时拿到元素和索引
for i, value in enumerate(['A', 'B', 'C']):
    print(i, value)

# 循环引用多个变量
for x, y in [(1, 1), (2, 4), (3, 9)]:
     print(x, y)
```

### 数据集合类型======================================================
1. 数组list
2. 元组turple
3. set
4. dict字典
#### 字符串
- 字符串是集合, 但是他并不是基础类型, 他是用元组包装的语法糖

```python
x='江流天地外, 山色有无中'

# 游标
x[8]

# 切片
x[1:6]

# ? 联接的两种写法, 空格和+号的优先级不同, 下面两行的结果不同
3*'xx' 'oo'*2
3*'xx'+'oo'*2


# ! 魔术代码 rfb, readonly format bytecode
# 不转义字符串
r'C:\some\name'

# ? f 格式字面值, 才是最终大家使用的方式
r = 2.5
s = 3.14 * r ** 2
f'半径{r}的面积={s:.2f}'
# 下面是输出, :冒号后面是格式
The area of a circle with radius 2.5 is 19.62

# b 字符串编码格式
b'ABC'.decode('ascii')
'ABC'
b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
```

#### array/list: ['关羽', '赤兔', '貂蝉']
```python
c = ['关羽', '赤兔', '貂蝉']
c[0] #第一个元素
c[-1] #最后一个元素
# ! 二维数组展平, 如果用了numpy这个会很优雅
a = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
sum(a, []) # 有兴趣的同学可以去renference看sum函数的用法
```

#### turple元组 : ('关羽', '赤兔', '貂蝉')
- 字符串可以认为是一种turple
- 括号很多时候可以省略, 此时会导致很多错觉
```python
# 类似list, 但是, 不可变
c = ('关羽', '赤兔', '貂蝉')
# 取数同样
c[0]
c[-1]
# 只有一个元素, 有歧义, 因此需要一个逗号
t = (1,)
# 等号两边都可以turble, 并且都可以省略括号
a, b = b, a + b

```

#### dict字典: {'关羽': 58, '貂蝉': 24, '赤兔': 35}
```python
# 其他语言: hash哈希/map
d = {'关羽': 58, '貂蝉': 24, '赤兔': 35}
d['关羽']
# 设置值
d['关羽'] = 67
# 判断key存在
 '董卓' in d
# 安全的取值, 如果不存在就返回指定的值, 例如-1
d.get('张飞', -1)
# 类似list, pop取值, 并且删除了这个key
d.pop('赤兔')

```

#### set: {'关羽', '赤兔', '貂蝉'}
```python
s={'关羽', '赤兔', '貂蝉'}
# 不重复的key的集合
s = set([1, 2, 3])
# 把turple放进去也是可以的
s= set((1,2,3))
# 把dict放进去, 会只筛选出key
s= set({'关羽': 58, '貂蝉': 24, '赤兔': 35})

# 可以add/remove
# 可以做& |等集合操作
```

### 集合操作方式
1. 数组list
2. 元组turple
3. set
4. dict字典

#### slice切片: L[4:10:2]
```python

# ? 至少课后都练习一下
L[0:3] # 前三个元素, 0,1,2
L[:3]

L[-2:] # 最后两个元素
L[-2:-1] # 倒数第二个元素(只有一个元素)


L[:10:2] # 前十个数, 每2个取一个, 0,2,4,6,8

# ? 课上至少做这2个练习
L[::5] # 所有数, 每5个取一个, 0, 5, 10...
L[:] # 原样复制一个
```

#### Comprehensions生成式  [x for x in L]
```python
# ? 练习
[x * x for x in range(1, 11)]
[(m,n) for m in '天地人' for n in '贪嗔痴']

# 这里使用了dict, 实际是元组
[f'{k}={v}' for k, v in d.items()]
[f'{k}={v}' for k, v in [('关羽', 58), ('貂蝉', 24), ('赤兔', 35)]]

# if
[x * x for x in range(1, 11) if x % 2 == 0] #if判断式
[x if x % 2 == 0 else -x for x in range(1, 11)] #if表达式expresion


```

## 集合总结
- 哪一个数据结构最重要?

## 函数==============================================================


```python
# ! 返回值实际是一个元组, 可以省略括号
def x2(x):
    nx = x*x
    ny = x**2
    return nx, ny

# ! 参数
# ? 默认参数是个变量, 重复调用会被记下来, 有memory效果, 堪称拔群
def ae(L=[]):
    L.append('完了') # L=f'{L}完了' 试试这个
    return L
ae()
ae()

# *号之后是key, **自动组装dict
def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
# turple和dict可以形成调用
args = (1, 2, 3)
kw = { 'x': 7, 'd': 88}
f2(*args, **kw) # 第一个参数是元组解构, 第二个参数是dict解构
f2(1,2,3, x=7,d=88) # 等于这个调用
```


### functional基础能力

```python


# 函数可以作为变量
x=x2
x(-100)
# 函数可以作为参数
def add(x, y, f):
    return f(x) + f(y)

add(20, 30, x)

# 函数作为返回值
def ls(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
a=ls(2,3,4) # 此时并未计算
a() # 此时才计算了

```
###### 匿名函数
```python

# 匿名函数
lambda x: x * x # :冒号前面是参数, 后面是返回值
(lambda : ('a', 'b')[1<0])()

```

### 生成器 generator (x for x in L)
- 
- 边运行边计算
```python
g = (x * x for x in range(10))

# 拿到下一个元素
next(g)
# 循环拿元素
for n in g:
     print(n)

# ! 函数写法
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'

# 调用
for n in fib(6):
    print(n)
# 此时拿不到返回值, 因为每次拿的都是yield值, 要拿返回值, 需要捕获错误
g = fib(6)
while True:
     try:
         x = next(g)
         print('g:', x)
     except StopIteration as e:
         print('Generator return value:', e.value)
         break

```
###### map/reduce

```python
# map转化的是iterator, 是惰性的, 因此强制转化为list, 方便打印
list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
# reduce类似迭代器, 保留前一个运算结果和下一个元素进行计算
from functools import reduce
def fn(x, y):
     return x * 10 + y
reduce(fn, [1, 3, 5, 7, 9])
# filter 类似map, 根据true false 决定是否保留值
def is_odd(n):
    return n % 2 == 1
list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# sorted接受一个函数作为排序依据
sorted([36, 5, -12, 9, -21], key=abs)
```