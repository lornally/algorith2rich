### 1. 基本TSP算法

我们将之前的思路应用于旅行商问题: 

* 令 S 为所有边的集合 [即 n 个城市之间的 n(n-l)/2 条边]
* 并令 T 为通路, 他是的 S 的子集, 有n个条边, 且满足约束C
* 目标函数f: 我们想要找到一个长度最小的通路
  * 考虑长度为 f(T) 的任意通路 T 和长度为 f(T') <f(T) 的通路游览 T'
  * 假设 T 和 T' 相差 k 条边（整体n条边 )
  * 我们的基本算法尝试通过顺序识别 T 和 S-T 之间要交换的 k 条边来将 T 转换为 T'
  * 也就是说，我们尝试找到两组边 X= {x~1~, * * *, x~k~} 和 Y= { y~1~, ..., y~k~}
  * 然后删除/破坏 X边, 然后替换为Y边，则结果是成本更低通路

![lk3opt到lkh5opt.025](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.025.jpeg)

###### 图1(k=3)

* 图1(a)是行程T，表示X和Y； 
* 图 1 (b) 显示了所得的 T'。 
* 注意，边用自然序编号：x~i~ 和 y~i~ 共享一端，y~i~ 和 x~i+1~共享另一端。 从而执行此编号，将 T 顺序转换为 T'。 

![lk3opt到lkh5opt.026](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.026.jpeg)

###### 图 2

* 显示了一个不可能进行这种编号的示例(opt4)。这种情况在我们研究的问题中很少出现。(注, 后续的lkh改进集中于此)

#### 假如这个编号成立

假设可以进行这种编号(只是为了描述方便, 并非必要条件)，希望找到待交换的边对: x~1~,y~1~;  x~2~, y~2~; ... 等。由于我们不知道 T' 可能是什么(T也是不知道的)，因此寻找任何将 T 化为 T' 且 f(T') <f (T) 的序列，并在 T' 上迭代该过程 直到无法进一步减少为止。

#### 正的子序列

设 x~i~ 和 y~i~ 的长度分别为 |x~i~| 和 |y~i~|，并定义 g~i~= |x~i~| - |y~i~| 这就是x~i~与y~i~交换的收益。 虽然有些 g~i~ 可能是负的，但如果 f(T') <f (T)，显然 $\sum_1^k{g_i} = f(T) -f(T') >0 $   , 算法部分基于以下简单的事实：

* 如果一个数字队列具有正和，
* 则将此队列视作循环队列，
* 我们可以切割此循环队列为多个子段落, 使每一子段落都是正和

证明(只要有最小值, 就可以保证这个切割成立): 

1. 假设k为最大索引, 保证g~1~+...+g~k-1~是最小值

2. 如果$k \leq j \leq n$, 

   g~k~+...+g~j~ =(g~1~+...+g~j~)-(g~1~+...+g~k-1~)>0

3. 如果$1 \leq j<k$,

   (g~k~+...+g~n~)+(g~1~+...+g~j~)>=(g~k~+...+g~n~)+(g~1~+...+g~k-1~)>0

由于我们正在寻找具有正和的 g~i~ 序列，==因此我们只需要考虑其部分和始终为正的增益序列==。 这个增益标准使我们能够极大地减少需要检查的序列数量； 这是我们停止规则的核心。

#### 概述基本启发式算法



> 图 3 说明了该算法。

图例:

1. x初始的边
2. y替换x的, 形成改进的边
3. t, x的点, 同时也是y的点

###### 图三, 描述了步骤(4),  其中

* a: i=2, 
* b: i=4, 注意此时t~8~是唯一的, 
* c: i=5, 注意t~2~(原文t~5~应是笔误~~~mck)的两个边都被打破了(由此, x5倍打破后只能连回t1形成通路)
* d: 步骤(6)c描述的, 关于y~1~的选择

![lk3opt到lkh5opt.027](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.027.jpeg)



![lk3opt到lkh5opt.028](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.028.jpeg)

#### 步骤

1. 生成一个随机的通路T

2. 设G*=0, G是目前为止最好的改进, 选择任意节点t~1~,  设x~1~为联通t~1~的边(属于通路T), 此时i=1

3. 从x~1~的另一个顶点t~2~ 链接一条边y~1~ 到t~3~, 让g~1~>0.  如果没有这样的y~1~, 那么就是到步骤(6)D(这是增益原则的一次应用)

4. 此时i=i+1,  选择x~i~(他的两个端点t~2i-1~和t~2i~), 和y~i~, 选择x~i~的方式如下: 

   a. 当我们选择了边x~i~时, 如果t~2i~连接到t~1~, 那么这里形成了通路(这是可行性原则, 任何时候, 连回t~1~都可以闭环一个通路)

   b. x~i~的端点t~2i~开始选择y~i~, 步骤cbd, 如果y~i~不存在, 跳转(5). (为了节约计算量y~i~只在邻域选择, 参考隔壁-3改进-B前瞻)

   ​	c. 为了保证x和y的正确性, x不能是之前的y, y也不能是之前的x

   ​	d. $G_i=\sum_{1}^{i}{g_j} > 0 $ 

   ​	e. 4a描述的通路保证, y~i~的另一个端点t~2i+1~必须可以引出可被打破的边 x~i+1~, (简单地说, x~i+1~的另一个端点t~2i+2~必须能连回t~1~成为通路)

   f. 正式确定y~i~之前, 我们要确认这个改进是目前为止的最佳改进. (我们需确认目前是一个通路, 考虑$i\geq2$的情况), 

   * 此时, 使 y~i~\*作为链接t~2i~和t~1~的边, 并且g~i~\*=|y~i~\*|-|x~i~|. 
   * 如果G~i-1~+g~i~\* > G\*, 那么 G\*=G~i-1~+g~i~\*,且k=i. 
   * 在通路T中, 目前为止G\*是最佳方案, 因此作为比较标准。$G^* \geq 0$，并且是单调非减的. 目前为止i的最大值是k, x~1到k~和y~1到k~定义了需要交换的边

5. 当没有进一步的链接 xi 和 yi 满足 4(c)-(e) 时，或者当 Gi<G\* 时，终止步骤 2 到 4 中 xi 和 yi 的构造。 [这是停止标准。] 

   * 如果 G\*>O，则用G\* 形成通路T'，并使用 T' 作为初始通路，跳转步骤 2 继续。

6. 如果 G* =0，则调用有限回溯功能，如下所示：

   (a) 重复步骤 4 和 5，按照长度递增的顺序选择 Y~2~，只要它们满足增益准则g~1~ +g~2~ >0。 任何改进都会导致跳转步骤2
   (b) 如果步骤 4(b) 中 y~2~ 的所有选择都用尽而没有改进，则返回步骤 4(a) 并尝试 x~2~ 的替代选择。 [y~1~的另外一个临边,  这里会导致实际不是一个通路, 我们在(8)和图4详细讨论这一步。]
   (c) 如果这也未能提供改进，则执行步骤 3 的进一步尝试，其中按长度递增的顺序检查 y~1~
   (d) 如果 y~1~ 也耗尽而没有改进，我们在步骤 2 中尝试替代 x~1~(t~1~的另一个边)

   (e) 如果失败，则选择一个新的 t~1~，然后重复步骤 2。

   [请注意，仅当找不到增益时才执行此回溯，并且仅在级别 1 和 2（i = 1 和 i = 2）处执行。 我们将在下一节中进一步讨论回溯。]

7. 当 t~1~ 的所有的 n个 值都已被检查且没有任何改进时，该过程终止。 这时，我们可以考虑在步骤1中进一步随机游览。

   

![lk3opt到lkh5opt.029](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.029.jpeg)

###### 图四展示了x2的后续情况

* (a), x2是不可以直接close的
* (b), x3有两个可能(黄点描述了t6的两个可能 ~~~mck)
* (c), x3只有一个可能(t6只有一个可能, 另一边也是导致了无法闭环~~~mck), y3也受到了限制

8. 除了讨论破坏位于 t3 的 t1方向(图4)的 x2 的影响之外，算法的描述到此结束，如图 4(a) 所示。 我们允许此种可能性，因为虽然它增加了一些复杂性，但它大大提高了整体效率。 仅当 i=2 时才允许选择不可行的替代方案。



* 在图 4(a) 中，Y2 不得与 t~1~ 连接，因为这会留下两个不相连的半部。 
* 现在，如果 t5 位于 t2 和 t3 之间，则 t6 可能位于 t5 的任一侧，并且事实上，两个方向都会被尝试。 见图4(b)。
* 如果t5位于t1和t4之间，如图4（c）所示，则
  * t6和t7为一个组合选择
    * t6只有一个选择（它必须位于t5和t4之间，保证可联通）
    * 且t7必须位于t2和t3之间, 
  * 但是t8可能在t7的两边, 此时, 我们选择一个使得|x4|最大.

#### 现在我们回过头来再次讨论步骤4

![lk3opt到lkh5opt.030](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.030.jpeg)

###### 图五, 一个示例

- (a), 步骤3
- (b), 步骤4 i=2的时候是可以闭环的
- (c), 唯一的x3的选择, i=3有闭环潜力
- (d), 禁手x3和t6

##### 一个例子

* 从图 5(a) 显示的通路 T 和两个相邻节点t1 和 t2开始； x1是连接它们的边。 令 t3 为距离 t2 最近的节点； Y1 是边（t2，t3）。由于 x 和 y 不相交，因此 y1 不能是已经联通t2的边(不允许是T中已有边)。 设 g1 = |x1| - |y1|; 如果这不是正数，我们返回[步骤 6(d)] 并选t1 的另一边的邻居作为t2。 设i=2，t4为t3的邻居，如图5(b)所示。 x2 是边 (t3, t4)。
* 现在，如果选择 Y2 将 t4 连接到 t1，结果将是一条通路，如果 g1+g2>0，我们可以通过用 Y1 和 Y2 交换 x1 和 x2 来改进 T。 记住这个潜在的改进——这是G\*； 步骤4(f), k=2时。 选择 距离t4最近的t5 作为边y2 (t4, t5)。 同样，t5 不能是任何一个已经和t4联通的节点(邻居~~~mck)
* 如图 5(c) 所示，t6 和x3只有一种选择 - 如果我们让 X3 为t5的另外一个邻居, 那么通路会成为两个分离的部分(两截断头路~~~mck)，如图5（d）所示。
* 再次，我们检查闭环（将 t6 连接到 t1）是否比通过将 t4 连接到 t1更优, 从而更新 G\* 并设置 k =3。 如果 $g1 +g2+g3 \leq G*$，则触发停止规则: k = 2 。如果 Y3 是最佳选择，我们同样停止与(t6, t1)。 否则，我们继续选择 t7，依此类推。

实际测试表明，此算法的计算量远远小于浅遍历，很大程度上是因为增益标准非常强。 每个局部最优值的计算时间取决于回溯量，但正如我们所描述的，计算量约为 n^2.2^(可能是n^2^~log~n)。 我们将在第 3 节(第4文档计算量部分)末尾进一步讨论这一点。

通路可行性的判断标准对于$i \geq 2或3$(取决于x2的选择)是安全的。 因为在每个阶段我们都尝试通过选择较小的 Yk 来最大化 G，实际上是寻找不合适的边. 在 $G_k \leq G^*$ 时立即终止，由此我们剪枝了无结果的深度探索。 平均超调量（即搜索深度减去k)的值并不大。 通常情况下，最初发现的几项改进过程具有较大的 k 值：一般有(3/4)n的局面是无改进的。 逐渐地，改进变得越来越难找到，最终为一系列较小的变化（大约 2-7）。 改进的数量通常在n/4和n/3之间。
很容易看出，从该启发式算法获得的局部最优解必然是参考文献11(lin较早的3opt文章)意义上的3-opt，因此保证结果与参考文献11中获得的结果一样好，并且时间要少得多。

##### 回溯

正如基本程序的步骤 6 和 7 中提到的，回溯受到严格限制。 显然，原则上可以通过在所有级别上进行回溯来找到最佳方案，但是这样一个过程的运行时间将是巨大的。 我们的回溯平衡了时间和能效。 

* 邻域的选择量

  * 测量表明，如果要在某个节点处找到增益，通常是第一个选择（第一级的平均选择数为 1.2，第二级为 1.8）。 

  * 因此，我们实际上只考虑y1和y2的几个选项（目前各最多五个）。 

  * 实验表明，这对最优值的频率没有显着影响，相对于在考虑所有 y1 和 y2 的情况下，运行时间减少了近两倍。 

  * 如果 Y1 和 Y2 各只有两个选项，确实会降低质量，尽管运行时间也会进一步减少。

* 回溯的层数

  * 第三层回溯会极大的增加时间开销。 

  * 仅在第一级回溯会削弱效果：成本低，但最优方案的出现频率较低。 （对于大问题或全局最优值不重要的问题，这可能是值得节省的）