### 1. 基本TSP算法

为了将此方法应用于旅行推销员问题，令 S 为所有边的集合 [即 n 个城市之间的 n(n-l)/2 条边]，并令 T 为通路, 他是的 S 的子集, 有n个条边, 且满足约束C. 我们想要找到一个长度最小的通路（目标函数 f）。
考虑长度为 f(T) 的任意游览 T 和长度为 f(T') <f(T) 的任意游览 T'。 假设 T 和 T' 相差 k 个链接（作为 n 个链接的集合）。 我们的基本算法尝试通过顺序识别 T 和 S-T 之间要交换的 k 对链接来将 T 转换为 T'。 也就是说，我们尝试找到两组链接(边) X= I x1, * * *, xk} 和 Y= { yl, 。 , yA} 这样，如果 X 中的链接被删除或“破坏”并被 Y 中的链接替换，则结果是成本更低的旅行。

![lk3opt到lkh5opt.025](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.025.jpeg)

###### 图1说明了k=3的情况。

图1(a)是行程T，表示X和Y； 图 1 (b) 显示了所得的 T'。 请注意，我们以自然的方式对受影响的链接进行了编号：x~i~ 和 y~i~ 共享一个端点，y~i~ 和 x~i+1~共享另一个端点。 通常可以执行此编号，从而将 T 顺序转换为 T'。 

![lk3opt到lkh5opt.026](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.026.jpeg)

###### 图 2

显示了一个不可能进行这种编号的示例。这种情况在我们研究的问题中很少出现。

假设可以进行这种编号(只是为了描述方便, 并非必要条件)，我们希望可以找到这些待交换的边x~1~,y~1~;  x~2~, Y~2~; ... 等。由于我们不知道 T' 可能是什么，因此当然要尝试找到任何将 T 化为 T' 且 f(T') <f (T) 的序列，并在 T' 上迭代该过程 直到无法进一步减少为止。
设 x~i~ 和 y~i~ 的长度分别为 |x~i~| 和 |y~i~|，并定义 g~i~= |x~i~| - |y~i~| 这就是x~i~与y~i~交换的收益。 虽然有些 g~i~ 可能是负的，但如果 f(T') <f (T)，显然我们有 g~i~ =f(T) -f(T') >0。 我们的过程的一部分基于以下简单的事实：如果一个数字序列具有正和，则此序列(循环)至少存在一个子序列(循环)，他的每个组成部分和都是正的.

证明: 

1. 假设k是最大的集合的索引(循环数列的元素数量), 保证g~1~+...+g~k-1~是最小值(注意, 此处是==循环==序列的最小值)

2. 如果k<=j<=n, 

   g~k~+...+g~j~ =(g~1~+...+g~j~)-(g~1~+...+g~k-1~)>0

3. 如果1<=j<k,

   (g~k~+...+g~n~)+(g~1~+...+g~j~)>=(g~k~+...+g~n~)+(g~1~+...+g~k-1~)>0

特别是，由于我们正在寻找具有正和的 g~i~ 序列，==因此我们只需要考虑其部分和始终为正的增益序列==。 这个增益标准使我们能够极大地减少需要检查的序列数量； 这是我们停止规则的核心。
我们现在概述基本启发式算法。 



> 图 3 说明了该算法。

图例~~~mck:

1. x初始的边
2. y替换x的, 形成改进的边
3. t, x的点, 同时也是y的点

![lk3opt到lkh5opt.027](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.027.jpeg)

1. 生成一个随机的通路T

2. 设G*=0, G是目前为止最好的改进, 选择任意节点t~1~,  设x~1~为联通t~1~的边(属于通路T), 此时i=1

3. 从x~1~的另一个定点t~2~ 链接一条边y~1~ 到t~3~, 让g~1~>0.  如果没有这样的y~1~, 那么就是到步骤6D(这是增益原则的一次应用)



![lk3opt到lkh5opt.028](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.028.jpeg)

###### 图三, 描述了步骤4,  其中

* a: i=2, 
* b: i=4, 注意此时t~8~是唯一的, 
* c: i=5, 注意t~2~(原文t~5~应是笔误~~~mck)的两个边都被打破了, 
* d: 步骤6c描述了的, 关于y~1~的选择

4. 此时i=i+1,  选择x~i~(他的两个端点t~2i-1~和t~2i~), 和y~i~, 选择x~i~的方式如下: 

   a. 当我们选择了边x~i~时, 如果t~2i~连接到t~1~, 那么这里形成了通路(理由是: 任何的新边y~i-1~都必然联系唯一且不重复的x~i~, 这保证了我们一定可以闭环: 通过联通t~2i~到t1, 4e步骤选择了y~i-1~,这个步骤保证了我们一定有x~i~)

   b. y~i~和x~i~公用终点t~2i~, 参考后面cbd三个条, 如果y~i~不存在, 参考条5. (因为要节约第i个步骤, 所以y~i~要比较小才行, 因此, 此时可以用邻域的概念, 找相邻较近的点连接y~i~)

   c. 为了保证x和y的正确性, x不能是之前的y, y也不能是之前的x

   d. $G_i=\sum_{1}^{i}{g_j} > 0 $ , 标准(初始~~~mck)增益

   e. 为了保证a描述的可行性, y~i~必须联通x~i+1~, (另一端联通x~i~ ~~~mck)

   f. 正式确定y~i~之前, 我们要确认这个改进是目前为止的最佳改进. (我们确认目前是一个通路, 只要$i\geq2$), 此时, 使 y~i~\*作为链接t~2i~和t~1~的边, 并且g~i~\*=|y~i~\*|-|x~i~|. G~i-1~+g~i~\* > G\*, 让 G\*=G~i-1~+g~i~\*,且k=i. (在通路T中, 目前为止G\*是最佳方案)[G\* 始终是迄今为止记录的 T 的最佳改进，因此是我们的比较标准。 G\* >O，并且是单调非减的。 索引 k 定义了要交换以获得 G\* 的集合。] ---此段落并未理解, ~~~mck todo

5. 当没有进一步的链接 xi 和 yi 满足 4(c)-(e) 时，或者当 Gi<G\* 时，终止步骤 2 到 4 中 xi 和 yi 的构造。 [这是我们的停止标准。] 如果 G\*>O，则以 f(T') =f(T) - G\* 形成通路T'，并使用 T' 作为初始通路，重复步骤 2 的整个过程。

6. 如果 G* =0，则调用有限回溯功能，如下所示：

   (a) 重复步骤 4 和 5，按照长度递增的顺序选择 Y~2~，只要它们满足增益准则g~i~ +g~2~ >0。 [如果任何时候发现改进，当然，这会导致返回步骤 2。]
   (b) 如果步骤 4(b) 中 y~2~ 的所有选择都用尽而没有改进，则返回步骤 4(a) 并尝试 x~2~ 的替代选择。 [打破替代x~2~引入临时违规可行性； 我们在算法描述之后详细讨论这一步。]
   (c) 如果这也未能提供改进，则执行步骤 3 的进一步尝试，其中按长度递增的顺序检查 y~i~
   (d) 如果 y~1~ 也耗尽而没有改进，我们在步骤 2 中尝试替代 x~1~

   (e) 如果失败，则选择一个新的 t~1~，然后重复步骤 2。

   [请注意，仅当找不到增益时才执行此回溯，并且仅在级别 1 和 2（i = 1 和 i = 2）处执行。 我们将在下一节中进一步讨论回溯。]

7. 当 t~1~ 的所有的 n个 值都已被检查且没有任何改进时，该过程终止。 这时，我们可以考虑在步骤1中进一步随机游览。

![lk3opt到lkh5opt.029](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.029.jpeg)

###### 图四展示了x2的后续情况

* (a), x2是不可以直接close的
* (b), x3有两个可能(黄点描述了t6的两个可能 ~~~mck)
* (c), x3只有一个可能(t6只有一个可能, 另一边也是导致了无法闭环~~~mck), y3也受到了限制

除了讨论破坏位于 t3 和 ti 之间的 x2 的影响之外，算法的描述到此结束，如图 4(a) 所示。 我们允许后一种可能性，因为虽然它增加了一些复杂性，但它大大提高了整体效率。 仅当 i=2 时才允许选择不可行的替代方案。
在图 4(a) 中，Y2 不得与 ti 连接，因为这会留下两个不相连的半部。 现在，如果 t5 位于 t2 和 t3 之间，则 t6 可能位于 t5 的任一侧，并且事实上，如果第一种可能性不会导致有利可图的交换，则将研究第二种可能性。 见图4(b)。
如果t5位于t1和t4之间，如图4（c）所示，则t6只有一个选择（它必须位于t5和t4之间，以满足可行性标准）并且t7必须位于t2和t3之间, 但是t8可能在t7的两边, 此时, 我们选择一个使得|x4|最大.

现在我们回过头来再次讨论步骤4

![lk3opt到lkh5opt.030](/Users/bergman/X/algorith2rich/history/20221205TSP:VRP系列/1LKH/论文/lk1971全文翻译/lk3opt到lkh5opt/lk3opt到lkh5opt.030.jpeg)

###### 图五, 一个示例

- (a), 步骤3
- (b), 步骤4 i=2的时候是可以闭环的
- (c), 唯一的x3的选择, i=3有闭环潜力
- (d), 禁手x3和t6

##### 一个例子

从图 5(a) 显示的通路 T 和两个相邻节点t1 和 t2开始； x1是连接它们的边。 令 t3 为距离 t2 最近的节点； Y1 是边（t2，t3）。由于 x 和 y 不相交，因此 y1 不允许是已连接到 t2 的任何一条边(邻居~~~mck)。 设 g1 = |x1| - |y1|; 如果这不是正数，我们返回[步骤 6(d)] 并选t1 的另一边的邻居作为t2。 设i=2，t4为t3的邻居，如图5(b)所示。 x2 是边 (t3, t4)。

现在，如果选择 Y2 将 14 连接到 ti，结果将是一条通路，如果 g1+g2>0，我们可以通过用 Y1 和 Y2 交换 x1 和 x2 来改进 T。 记住这个潜在的改进——这是G\*； 步骤4(f), k=2时。 选择 距离t4最近的t5 作为边y2 (t4, t5)。 同样，t5 不能是任何一个已经和t4联通的节点(邻居~~~mck)

如图 5(c) 所示，t6 和x3只有一种选择 - 如果我们让 X3 为t5的另外一个邻居, 那么通路会成为两个分离的部分(两截断头路~~~mck)，如图5（d）所示。

再次，我们检查闭环（将 t6 连接到 t1）是否比通过将 t4 连接到 t1更优, 从而更新 G\* 并设置 k =3。 如果 $g1 +g2+g3 \leq G*$，则触发停止规则: k = 2 。如果 Y3 是最佳选择，我们同样停止与(t6, t1)。 否则，我们继续选择 t7，依此类推。

实际测试表明，此算法的计算量远远小于浅遍历，很大程度上是因为增益标准非常强。 每个局部最优值的计算时间取决于回溯量，但正如我们所描述的，计算量约为 n^2.2^(可能是n^2^~log~n)。 我们将在第 3 节末尾进一步讨论这一点。

通路可行性的判断标准对于$i \geq 2或3$(取决于x2的选择)是安全的。 因为在每个阶段我们都尝试通过选择较小的 Yk 来最大化 Gk，实际上是寻找不合适的边. 在 $G_k \leq G^*$ 时立即终止，由此我们剪枝了无结果的深度探索。 平均超调量（即搜索深度减去k)的值并不大。 通常情况下，最初发现的几项改进过程具有较大的 k 值：一般有(3/4)n的局面是无改进的。 逐渐地，改进变得越来越难找到，最终为一系列较小的变化（大约 2-7），有一些超调。 改进的数量通常在n/4和n/3之间。
很容易看出，从该启发式算法获得的局部最优解必然是参考文献11意义上的3-opt，因此保证结果与参考文献11中获得的结果一样好，并且时间要少得多。

##### 回溯

正如基本程序的步骤 6 和 7 中提到的，回溯受到严格限制。 显然，原则上可以通过在所有级别上进行回调来找到最佳方案，但是这样一个过程的运行时间将是巨大的。 我们的回溯平衡了时间和能效。 

测量表明，如果要在某个节点处找到增益，通常是第一个选择（第一级的平均选择数为 1.2，第二级为 1.8）。 因此，我们实际上只考虑y1和y2的几个选项（目前各最多五个）。 实验表明，这对最优值的频率没有显着影响，相对于在考虑所有 yi 和 Y2 的情况下，运行时间减少了近两倍。 如果 Y1 和 Y2 各只有两个选项，确实会降低质量，尽管运行时间也会进一步减少。
第三层回溯会极大的增加时间开销。 仅在第一级回溯会削弱效果：尽管与具有更多回溯的解决方案相比，解决方案具有相当好的成本，但最优方案的出现频率较低。 （对于大问题或全局最优值不重要的问题，这可能是值得节省的）