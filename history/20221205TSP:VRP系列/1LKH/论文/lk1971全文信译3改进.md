### 2. 改进

之前描述的算法非常有效，但我们还是添加了一些改进，可以大大提高效果，而无需显着的额外成本。

##### A. 避免核验时间(禁忌所搜~~~mck)

当通路T的值为f时, 在某个节点t，然后无法取得进步，我们说 T 是局部最优的，由此定义核验时间为: 发现T之后, 继续检查所有可能性直到确认T是局部最优解, 所花费的时间, 如果在稍后的情况下，我们到达同一个旅行 T，则尝试找到进一步的减少是没有意义的——这种情况之前已被“核验过过”。' 因此，在无法进行改进的情况下，为了节省运行时间
节点，测试得到的解是否与之前的解相同； 如果是这样，可以避免核验时间。 这通常占时 30% 到 50%的运行时间。

##### B. 前瞻

所描述的过程选择链接yi，而不考虑x~i+1~(必须在下一阶段将其破坏)大小。 如果这个 x~i+1~ 实际上是一个“好的”链接，即成本低的链接，其结果往往经过漫长而徒劳的追逐, 从而发现真相：打破 x~i+1~是错误的，因此 yi 是一个糟糕的选择。

为了克服这个弱点，在过程中添加了受限的前瞻：在选择 yi 的所有步骤中，选择不是基于 |yi| 而是通过尝试最大化|x~i+1~|-|yi| 来做出的。 当 i 为 1 或 2 时，这会改变链接的顺序考虑，这可能会对解决方案产生影响。 （参见下一段落）在后续阶段（$i\geq3$）中，意味着选择对应|x~i+1~|-|yi| 最大值的对应的yi。 人们可能会认为我们应该最大化|x~i+1~|-|yi| 在所有的处理 yi的时候，但经过实验，我们拒绝了这个，因为太耗时。 目前，我们使用五个最小（可用）yi 中发现的最大的|x~i+1~|-|yi|，它似乎同样有效且速度更快。

使用前瞻, 还有另一个更微妙的理由。如果我们决定仅在最近邻居优先的基础上加入链接，我们就陷入了局部最优。 这意味着每当可以选择加入此链接而不是其他链接, 最近邻居链接总是被选择，如果这是错误的，就没有办法避免它。 但如果我们使用|x~i+1~|-|yi|作为标准，可以选择也可以不选择 yi，具体取决于 x~i+1~，它是当前游览状态的函数，因此本质上更具全局性。这为程序提供了更大弹性，并提高了正解的机会。

##### C. 归约(剪枝:归并缩减)

一旦通过迄今为止所描述的过程找到了一些局部最优的通路，我们就会观察到某些链接出现在所有这些旅行中。 由于此后的过程所花费的大部分时间本质上是通过反复破坏这些良好链接来重复先前的工作，因此我们设计了一种缩减功能，尝试使用此信息来指导进一步的搜索（并顺便节省运行时间）。

发现了少量（当前在两个到五个之间）不同的局部最优值。 （如果我们无法在合理的尝试次数中找到两个不同的旅行，我们以此作为单一解决方案不会得到改进的初步证据。）记录所有这些解决方案共有的所有链接。 现在（“缩减后”）继续寻找局部最优解决方案，并附加限制，即如果链接 xi 出现在这组好链接中，则链接 xi 不会被破坏。 随着新的局部最优解的获得，继续记录分叉路口。

减少的影响可以通过多种方式感受到。 最明显的是戏剧性的运行时间减少（通常为五倍），因为剩下的可供评估的情况太少了。 减少程序已经“修剪了树”的可能情况。 如果局部最优游览有许多共同点（两个不同的局部最佳游览通常有 85% 的共同点，甚至 7 或 8 个也将有 60-80%），那么算法需要评估的可能性就会减少。 （请记住，良好的链接对应于 yi 的最小值，因此，当通过归约消除这些值时，增益标准将成为更强大的消除器。）

然而，节省时间并不是我们引入归约的唯一目的。 相反，归约是在一组原本无法区分的情况下进行搜索的一种方法。 实际上，我们的意思是，某些情况可能会立即被拒绝，因为它们涉及破坏链接，这些链接出现在太多优秀的旅游中，不可能是偶然的； 破坏这样的链接很可能是错误的，我们应该尝试其他方法。

但归约显然会使我们得到的解决方案产生偏差。 假设当我们寻找预还原旅行时，最优值没有出现。 那么归约的基础只包含次优解，而归约后的过程可能无法突破这一点而真正获得最优解。 因此，我们稍微修改了约简——在归约通路的岔路口, 没有 xi 可能会在 4 级或更深级别被破坏, 我们仍然可以在级别 1、2 和 3 处根据需要断开链接。这种“部分减少”为我们提供了一些灵活性，可以从错误的减少选择中恢复，但保留了完全减少的大部分路径引导和节省时间的特性 。

由于该过程以遍历过得所有通路的岔路口的归约的基础，因此具有一定的收敛效果。 如果我们一开始的旅行很糟糕，但后来得到了正解，那么从那时起，最佳路线应该会更频繁地出现（尽管随着交叉路口变小, 耗时也减小了）。

##### D. 非顺序交换

正如我们之前观察到的（见图 2），某些配置无法通过更改链接的连接序列来改进。对此, 运算过程增加了有限的针对性改进。 找到局部最优的旅行后，我们测试在旅行中可能被破坏的链接中（由归约程序确定）是否可以通过交换(如图2所示)进行进一步的改进. 由于此归约和原始通路之间不同的链接数量很少(y1, y2, y3, y4, 就8个点~~~mck)，因此此测试很快。 该过程是否产生所需的改进因问题而异：在某些情况下，它将大多数非最佳解决方案转换为最佳解决方案，而在其他情况下，它没有任何效果。 在我们的实施中，每个独特游览的运行时间低于 50 毫秒，因此这并不是非常昂贵的保险。
